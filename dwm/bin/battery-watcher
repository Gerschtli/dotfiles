#!/usr/bin/env bash

BATTERY_BIN="battery"
LOCK_FILE_TEMPLATE="/tmp/battery-watcher-%02d.lock"

# sort levels ascending
LEVELS=(2 5 10 15)
CRITICAL=5


# check requirements
if ! $(hash "${BATTERY_BIN}" > /dev/null 2>&1); then
    echo "${BATTERY_BIN} is not in PATH" >&2
    exit 2
fi

"${BATTERY_BIN}" > /dev/null;
if [[ $? == 2 ]]; then
    exit 2
fi


USAGE_TEXT="
$(basename "$0") <action> -- manages battery notifaction service

notification levels are:
    ${LEVELS[@]}

where action is one of:
    default     fires notifications if neccessary and removes locks where possible
    reset       removes all locks
"


_build_lock_path() {
    printf "${LOCK_FILE_TEMPLATE}" "${1}"
}

_remove_lock_file() {
    rm -f "$( _build_lock_path "${1}" )"
}

_exists_lock_file() {
    [[ -e "$( _build_lock_path "${1}" )" ]]
}

_create_lock_file() {
    touch "$( _build_lock_path "${1}" )"
}

_notify() {
    local level="${1}"
    local estimation="$( ${BATTERY_BIN} estimation )"

    if (( $level <= $CRITICAL )); then
        local type="critical"
    else
        local type="normal"
    fi

    notify-send --urgency="${type}" "Battery under ${level}%" "${estimation} remaining"
}


_check_notify() {
    local percentage="${1}"

    # search for next level
    for level in "${LEVELS[@]}"; do
        if (( ${level} >= ${percentage} )); then
            if ! _exists_lock_file "${level}"; then
                _notify "${level}"
                _create_lock_file "${level}"
            fi
            break
        fi
    done
}

_remove_locks() {
    for level in "${LEVELS[@]}"; do
       _remove_lock_file "${level}"
    done
}

_main() {
    local state=$( ${BATTERY_BIN} state )
    local percentage=$( ${BATTERY_BIN} percentage )

    if [[ "${state}" == "discharging" ]]; then
        _check_notify "${percentage}"
    else
        _remove_locks
    fi
}

_usage() {
    echo "${USAGE_TEXT}"
}


case "${1}" in
    default) _main            ;;
    reset)   _remove_locks    ;;
    *)       _usage && exit 1 ;;
esac

exit 0
