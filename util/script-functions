source "${DOTFILES_ROOT}/shell/functions.sh"

_d_contains_element() {
    local e
    for e in "${@:2}"; do
        [[ "$e" == "$1" ]] && return 0
    done
    return 1
}

_d_error() {
    _d_print "31" "FAIL" "$@"
}

_d_get_symlink_target() {
    ls -l "${1}" 2> /dev/null | sed -e 's/.* -> //'
}

_d_has_module() {
    _d_contains_element "${1}" "${MODULES[@]}"
}

_d_has_option() {
    _d_contains_element "${1}" "${OPTIONS[@]}"
}

_d_indent() {
    local cmd="$1"
    if [[ "${cmd}" == "git" && "$(git --version)" != *1.7.* ]]; then
        cmd="git -c color.diff=always -c color.status=always"
    fi

    while IFS= read -r line; do
        printf "     > %s\n" "${line}"
    done < <(${cmd} ${@:2} 2>&1)
}

_d_info() {
    _d_print "34" "INFO" "$@"
}

_d_is_addable_to_path() {
    local dir="${1}"
    [[ -d "${dir}" && ! "${PATH}" =~ (^|:)"${dir}"(:|$) ]]
}

_d_link_file() {
    local target="${1}"
    local linkname="${2}"

    local cached_target="${links["${linkname}"]}"
    unset links["${linkname}"]

    if [[ "${cached_target}" != "${target}" ]]; then
        _d_remove_line_in_cache "${linkname}"
    fi

    if [[ $(_d_get_symlink_target "${linkname}") == "${target}" ]]; then
        if [[ "${cached_target}" != "${target}" ]]; then
            echo "${target}:${linkname}" >> "${CACHE_FILE}"
        fi
        return
    fi

    if [[ -e "${linkname}" && ! -L "${linkname}" ]]; then
        mv "${linkname}" "${linkname}${BACKUP_SUFFIX}"
        _d_info "Moved %s to %s" "${linkname}" "${linkname}${BACKUP_SUFFIX}"
    fi

    if ln -snf "${target}" "${linkname}"; then
        _d_success "Linked %s to %s" "${target}" "${linkname}"
        echo "${target}:${linkname}" >> "${CACHE_FILE}"
    else
        _d_error "Failed linking %s to %s" "${target}" "${linkname}"
        FAIL=true
    fi
}

_d_print() {
    local parameters=()
    for param in ${@:4}; do
        parameters+=("\033[1m${param/${HOME}/\~}\033[0m")
    done

    echo -e "[\033[00;${1}m${2}\033[0m] $(printf "${3}" "${parameters[@]}")"
}

_d_pull() {
    local path="${1}"

    if [[ $(git -C "${path}" rev-parse --abbrev-ref HEAD) != "master" ]]; then
        _d_info "git checkout master ..."
        git -C "${path}" checkout master
    fi

    _d_info "git pull ..."
    git -C "${path}" pull
}

_d_register_fpath() {
    fpath=("${1}" $fpath)
}

_d_remove_line_in_cache() {
    local tmp="$(mktemp -t "dotfiles-cache.XXXXXX")"

    [ ! -r "${CACHE_FILE}" ] && touch "${CACHE_FILE}"

    egrep -v ".*:${1}$" "${CACHE_FILE}" > "${tmp}" \
        && mv "${tmp}" "${CACHE_FILE}" || true
}

_d_source_files() {
    for file in $(find "${DOTFILES_ROOT}" -mindepth 2 -maxdepth 2 -type f "$@" | sort); do
        if _d_use_module "${file}"; then
            source "${file}"
        fi
    done
}

_d_success() {
    _d_print "32" " OK " "$@"
}

_d_use_module() {
    local file="${1}"
    local directory="${file%/*}"
    local module="${directory##*/}"
    _d_has_module "${module}"
}

# vim: ft=sh
