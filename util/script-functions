_d_contains_element() {
    local e
    for e in "${@:2}"; do
        [[ "$e" == "$1" ]] && return 0
    done
    return 1
}

_d_error() {
    _d_print "31" "FAIL" "$@"
}

_d_has_module() {
    _d_contains_element "${1}" "${MODULES[@]}"
}

_d_info() {
    _d_print "34" "INFO" "$@"
}

_d_link_file() {
    local src="${1}"
    local destination="${2}"

    local cached_src="${links["${destination}"]}"
    unset links["${destination}"]

    if [[ "${cached_src}" != "${src}" ]]; then
        _d_remove_line_in_cache "${destination}"
    fi

    if [[ $(_d_realpath "${destination}") == "${src}" ]]; then
        if [[ "${cached_src}" != "${src}" ]]; then
            echo "${src}:${destination}" >> "${CACHE_FILE}"
        fi
        return
    fi

    if [[ -e "${destination}" && ! -L "${destination}" ]]; then
        mv "${destination}" "${destination}${BACKUP_SUFFIX}"
        _d_info "Moved %s to %s" "${destination}" "${destination}${BACKUP_SUFFIX}"
    fi

    if ln -snf "${src}" "${destination}"; then
        _d_success "Linked %s to %s" "${src}" "${destination}"
        echo "${src}:${destination}" >> "${CACHE_FILE}"
    else
        _d_error "Failed linking %s to %s" "${src}" "${destination}"
        FAIL=true
    fi
}

_d_print() {
    local parameters=()
    for param in ${@:4}; do
        parameters+=("\033[1m${param/${HOME}/\~}\033[0m")
    done

    echo -e "[\033[00;${1}m${2}\033[0m] $(printf "${3}" "${parameters[@]}")"
}

_d_realpath() {
    realpath "${1}" 2> /dev/null
}

_d_remove_line_in_cache() {
    if [ -r "${CACHE_FILE}" ]; then
        sed -ie "\|.*:${1}$|d" "${CACHE_FILE}"
    fi
}

_d_source_files() {
    for file in $(find "${DOTFILES_ROOT}" -mindepth 2 -maxdepth 2 -type f "$@" | sort); do
        if _d_use_module "${file}"; then
            source "${file}"
        fi
    done
}

_d_success() {
    _d_print "32" " OK " "$@"
}

_d_use_module() {
    local file="${1}"
    local directory="${file%/*}"
    local module="${directory##*/}"
    _d_has_module "${module}"
}

# vim: ft=sh
